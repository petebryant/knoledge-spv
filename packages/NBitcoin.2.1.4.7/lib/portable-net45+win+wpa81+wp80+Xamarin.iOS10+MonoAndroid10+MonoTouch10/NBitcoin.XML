<?xml version="1.0"?>
<doc>
    <assembly>
        <name>NBitcoin</name>
    </assembly>
    <members>
        <member name="T:NBitcoin.Base58Data">
            <summary>
            Base class for all Base58 check representation of data
            </summary>
        </member>
        <member name="T:NBitcoin.IDestination">
            <summary>
            Represent any type which represent an underlying ScriptPubKey
            </summary>
        </member>
        <member name="T:NBitcoin.BitcoinExtKey">
            <summary>
            Base58 representation of an ExtKey
            </summary>
        </member>
        <member name="T:NBitcoin.BitcoinExtPubKey">
            <summary>
            Base58 representation of an ExtPubKey
            </summary>
        </member>
        <member name="T:NBitcoin.ExtKey">
            <summary>
            A private HD key
            </summary>
        </member>
        <member name="M:NBitcoin.ExtKey.Neuter">
            <summary>
            Create the public key from this key
            </summary>
            <returns></returns>
        </member>
        <member name="T:NBitcoin.ExtPubKey">
            <summary>
            A public HD key
            </summary>
        </member>
        <member name="P:NBitcoin.ExtPubKey.ScriptPubKey">
            <summary>
            The P2PKH payment script
            </summary>
        </member>
        <member name="T:NBitcoin.KeyPath">
            <summary>
            Represent a path in the hierarchy of HD keys (BIP32)
            </summary>
        </member>
        <member name="M:NBitcoin.KeyPath.Parse(System.String)">
            <summary>
            Parse a KeyPath
            </summary>
            <param name="path">The KeyPath formated like 10/0/2'/3</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.BitcoinEncryptedSecretEC.HashAddress(NBitcoin.BitcoinAddress)">
            <summary>
            Take the first four bytes of SHA256(SHA256(generatedaddress)) and call it addresshash.
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="T:NBitcoin.Mnemonic">
            <summary>
            A .NET implementation of the Bitcoin Improvement Proposal - 39 (BIP39)
            BIP39 specification used as reference located here: https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki
            Made by thashiznets@yahoo.com.au
            v1.0.1.1
            I â™¥ Bitcoin :)
            Bitcoin:1ETQjMkR1NNh4jwLuN5LxY7bMsHC9PUPSV
            </summary>
        </member>
        <member name="M:NBitcoin.Mnemonic.#ctor(NBitcoin.Wordlist,System.Byte[])">
            <summary>
            Generate a mnemonic
            </summary>
            <param name="wordList"></param>
            <param name="entropy"></param>
        </member>
        <member name="M:NBitcoin.Wordlist.#ctor(System.String[],System.Char,System.String)">
            <summary>
            Constructor used by inheritence only
            </summary>
            <param name="words">The words to be used in the wordlist</param>
        </member>
        <member name="M:NBitcoin.Wordlist.WordExists(System.String,System.Int32@)">
            <summary>
            Method to determine if word exists in word list, great for auto language detection
            </summary>
            <param name="word">The word to check for existence</param>
            <returns>Exists (true/false)</returns>
        </member>
        <member name="M:NBitcoin.Wordlist.GetWordAtIndex(System.Int32)">
            <summary>
            Returns a string containing the word at the specified index of the wordlist
            </summary>
            <param name="index">Index of word to return</param>
            <returns>Word</returns>
        </member>
        <member name="P:NBitcoin.Wordlist.WordCount">
            <summary>
            The number of all the words in the wordlist
            </summary>
        </member>
        <member name="T:NBitcoin.BitcoinScriptAddress">
            <summary>
            Base58 representaiton of a script hash
            </summary>
        </member>
        <member name="T:NBitcoin.BitcoinAddress">
            <summary>
            Base58 representation of a pubkey hash and base class for the representation of a script hash
            </summary>
        </member>
        <member name="M:NBitcoin.BitcoinAddress.Create(System.String,NBitcoin.Network)">
            <summary>
            Detect whether the input base58 is a pubkey hash or a script hash
            </summary>
            <param name="base58">The Base58 string to parse</param>
            <param name="expectedNetwork">The expected network to which it belongs</param>
            <returns>A BitcoinAddress or BitcoinScriptAddress</returns>
            <exception cref="T:System.FormatException">Invalid format</exception>
        </member>
        <member name="T:NBitcoin.BitcoinCore.TxInUndo">
            Undo information for a CTxIn
            
              Contains the prevout's CTxOut being spent, and if this was the
              last output of the affected transaction, its metadata as well
              (coinbase or not, height, transaction version)
        </member>
        <member name="M:NBitcoin.BitcoinCore.DiskBlockPosRange.#ctor(NBitcoin.BitcoinCore.DiskBlockPos,NBitcoin.BitcoinCore.DiskBlockPos)">
            <summary>
            Represent a disk block range
            </summary>
            <param name="begin">Beginning of the range (included)</param>
            <param name="end">End of the range (excluded)</param>
        </member>
        <member name="T:NBitcoin.BlockHeader">
            Nodes collect new transactions into a block, hash them into a hash tree,
            and scan through nonce values to make the block's hash satisfy proof-of-work
            requirements.  When they solve the proof-of-work, they broadcast the block
            to everyone and the block is added to the block chain.  The first transaction
            in the block is a special one that creates a new coin owned by the creator
            of the block.
        </member>
        <member name="M:NBitcoin.Block.Check">
            <summary>
            Check proof of work and merkle root
            </summary>
            <returns></returns>
        </member>
        <member name="T:NBitcoin.BlockLocator">
            <summary>
            Compact representation of one's chain position which can be used to find forks with another chain
            </summary>
        </member>
        <member name="T:NBitcoin.BloomFilter">
            <summary>
            Used by SPV client, represent the set of interesting addresses tracked by SPV client with plausible deniability
            </summary>
        </member>
        <member name="M:NBitcoin.ChainBase.SetTip(NBitcoin.ChainedBlock)">
            <summary>
            Force a new tip for the chain
            </summary>
            <param name="pindex"></param>
            <returns>forking point</returns>
        </member>
        <member name="T:NBitcoin.ChainedBlock">
            <summary>
            A BlockHeader chained with all its ancestors
            </summary>
        </member>
        <member name="M:NBitcoin.StealthCoin.Find(NBitcoin.Transaction,NBitcoin.Stealth.BitcoinStealthAddress,NBitcoin.Key)">
            <summary>
            Scan the Transaction for StealthCoin given address and scan key
            </summary>
            <param name="tx">The transaction to scan</param>
            <param name="address">The stealth address</param>
            <param name="scan">The scan private key</param>
            <returns></returns>
        </member>
        <member name="T:NBitcoin.ConcurrentChain">
            <summary>
            Thread safe class representing a chain of headers from genesis
            </summary>
        </member>
        <member name="M:NBitcoin.ConcurrentChain.SetTip(NBitcoin.ChainedBlock)">
            <summary>
            Force a new tip for the chain
            </summary>
            <param name="pindex"></param>
            <returns>forking point</returns>
        </member>
        <member name="T:NBitcoin.Crypto.Pbkdf2">
             <summary>
             Implements the PBKDF2 key derivation function.
             </summary>
             
             <example>
             <code title="Computing a Derived Key">
             using System.Security.Cryptography;
             using CryptSharp.Utility;
             
             // Compute a 128-byte derived key using HMAC-SHA256, 1000 iterations, and a given key and salt.
             byte[] derivedKey = Pbkdf2.ComputeDerivedKey(new HMACSHA256(key), salt, 1000, 128);
             </code>
             <code title="Creating a Derived Key Stream">
             using System.IO;
             using System.Security.Cryptography;
             using CryptSharp.Utility;
            
             // Create a stream using HMAC-SHA512, 1000 iterations, and a given key and salt.
             Stream derivedKeyStream = new Pbkdf2(new HMACSHA512(key), salt, 1000);
             </code>
             </example>
        </member>
        <member name="M:NBitcoin.Crypto.Pbkdf2.#ctor(NBitcoin.BouncyCastle.Crypto.IMac,System.Byte[],System.Int32)">
            <summary>
            Creates a new PBKDF2 stream.
            </summary>
            <param name="hmacAlgorithm">
                The HMAC algorithm to use, for example <see cref="!:HMACSHA256"/>.
                Make sure to set <see cref="!:KeyedHashAlgorithm.Key"/>.
            </param>
            <param name="salt">
                The salt.
                A unique salt means a unique PBKDF2 stream, even if the original key is identical.
            </param>
            <param name="iterations">The number of iterations to apply.</param>
        </member>
        <member name="M:NBitcoin.Crypto.Pbkdf2.Read(System.Int32)">
            <summary>
            Reads from the derived key stream.
            </summary>
            <param name="count">The number of bytes to read.</param>
            <returns>Bytes from the derived key stream.</returns>
        </member>
        <member name="M:NBitcoin.Crypto.Pbkdf2.ComputeDerivedKey(NBitcoin.BouncyCastle.Crypto.IMac,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Computes a derived key.
            </summary>
            <param name="hmacAlgorithm">
                The HMAC algorithm to use, for example <see cref="!:HMACSHA256"/>.
                Make sure to set <see cref="!:KeyedHashAlgorithm.Key"/>.
            </param>
            <param name="salt">
                The salt.
                A unique salt means a unique derived key, even if the original key is identical.
            </param>
            <param name="iterations">The number of iterations to apply.</param>
            <param name="derivedKeyLength">The desired length of the derived key.</param>
            <returns>The derived key.</returns>
        </member>
        <member name="M:NBitcoin.Crypto.Pbkdf2.Dispose(System.Boolean)">
            <summary>
            Closes the stream, clearing memory and disposing of the HMAC algorithm.
            </summary>
        </member>
        <member name="M:NBitcoin.Crypto.Pbkdf2.Flush">
            <exclude />
        </member>
        <member name="M:NBitcoin.Crypto.Pbkdf2.Read(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:NBitcoin.Crypto.Pbkdf2.Seek(System.Int64,System.IO.SeekOrigin)">
            <inheritdoc />
        </member>
        <member name="M:NBitcoin.Crypto.Pbkdf2.SetLength(System.Int64)">
            <exclude />
        </member>
        <member name="M:NBitcoin.Crypto.Pbkdf2.Write(System.Byte[],System.Int32,System.Int32)">
            <exclude />
        </member>
        <member name="P:NBitcoin.Crypto.Pbkdf2.CanRead">
            <exclude />
        </member>
        <member name="P:NBitcoin.Crypto.Pbkdf2.CanSeek">
            <exclude />
        </member>
        <member name="P:NBitcoin.Crypto.Pbkdf2.CanWrite">
            <exclude />
        </member>
        <member name="P:NBitcoin.Crypto.Pbkdf2.Length">
            <summary>
            The maximum number of bytes that can be derived is 2^32-1 times the HMAC size.
            </summary>
        </member>
        <member name="P:NBitcoin.Crypto.Pbkdf2.Position">
            <summary>
            The position within the derived key stream.
            </summary>
        </member>
        <member name="T:NBitcoin.Crypto.Salsa20Core">
            <summary>
            Implements the Salsa20 hash function.
            </summary>
        </member>
        <member name="M:NBitcoin.Crypto.Salsa20Core.Compute(System.Int32,System.UInt32[],System.Int32,System.UInt32[],System.Int32)">
            <summary>
            Applies the Salsa20 hash function.
            It maps a 16 element input to an output of the same size.
            </summary>
            <param name="rounds">The number of rounds. SCrypt uses 8.</param>
            <param name="input">The input buffer.</param>
            <param name="inputOffset">The offset into the input buffer.</param>
            <param name="output">The output buffer.</param>
            <param name="outputOffset">The offset into the output buffer.</param>
        </member>
        <member name="T:NBitcoin.Crypto.SCrypt">
            <summary>
            Implements the SCrypt key derivation function.
            </summary>
        </member>
        <member name="M:NBitcoin.Crypto.SCrypt.ComputeDerivedKey(System.Byte[],System.Byte[],System.Int32,System.Int32,System.Int32,System.Nullable{System.Int32},System.Int32)">
            <summary>
            Computes a derived key.
            </summary>
            <param name="key">The key to derive from.</param>
            <param name="salt">
                The salt.
                A unique salt means a unique SCrypt stream, even if the original key is identical.
            </param>
            <param name="cost">
                The cost parameter, typically a fairly large number such as 262144.
                Memory usage and CPU time scale approximately linearly with this parameter.
            </param>
            <param name="blockSize">
                The mixing block size, typically 8.
                Memory usage and CPU time scale approximately linearly with this parameter.
            </param>
            <param name="parallel">
                The level of parallelism, typically 1.
                CPU time scales approximately linearly with this parameter.
            </param>
            <param name="maxThreads">
                The maximum number of threads to spawn to derive the key.
                This is limited by the <paramref name="parallel"/> value.
                <c>null</c> will use as many threads as possible.
            </param>
            <param name="derivedKeyLength">The desired length of the derived key.</param>
            <returns>The derived key.</returns>
        </member>
        <member name="M:NBitcoin.Crypto.SCrypt.GetEffectivePbkdf2Salt(System.Byte[],System.Byte[],System.Int32,System.Int32,System.Int32,System.Nullable{System.Int32})">
            <summary>
            The SCrypt algorithm creates a salt which it then uses as a one-iteration
            PBKDF2 key stream with SHA256 HMAC. This method lets you retrieve this intermediate salt.
            </summary>
            <param name="key">The key to derive from.</param>
            <param name="salt">
                The salt.
                A unique salt means a unique SCrypt stream, even if the original key is identical.
            </param>
            <param name="cost">
                The cost parameter, typically a fairly large number such as 262144.
                Memory usage and CPU time scale approximately linearly with this parameter.
            </param>
            <param name="blockSize">
                The mixing block size, typically 8.
                Memory usage and CPU time scale approximately linearly with this parameter.
            </param>
            <param name="parallel">
                The level of parallelism, typically 1.
                CPU time scales approximately linearly with this parameter.
            </param>
            <param name="maxThreads">
                The maximum number of threads to spawn to derive the key.
                This is limited by the <paramref name="parallel"/> value.
                <c>null</c> will use as many threads as possible.
            </param>
            <returns>The effective salt.</returns>
        </member>
        <member name="M:NBitcoin.Crypto.SCrypt.GetStream(System.Byte[],System.Byte[],System.Int32,System.Int32,System.Int32,System.Nullable{System.Int32})">
            <summary>
            Creates a derived key stream from which a derived key can be read.
            </summary>
            <param name="key">The key to derive from.</param>
            <param name="salt">
                The salt.
                A unique salt means a unique scrypt stream, even if the original key is identical.
            </param>
            <param name="cost">
                The cost parameter, typically a fairly large number such as 262144.
                Memory usage and CPU time scale approximately linearly with this parameter.
            </param>
            <param name="blockSize">
                The mixing block size, typically 8.
                Memory usage and CPU time scale approximately linearly with this parameter.
            </param>
            <param name="parallel">
                The level of parallelism, typically 1.
                CPU time scales approximately linearly with this parameter.
            </param>
            <param name="maxThreads">
                The maximum number of threads to spawn to derive the key.
                This is limited by the <paramref name="parallel"/> value.
                <c>null</c> will use as many threads as possible.
            </param>
            <returns>The derived key stream.</returns>
        </member>
        <member name="T:NBitcoin.Crypto.DeterministicECDSA">
             Deterministic DSA signature generation.  This is a sample
             implementation designed to illustrate how deterministic DSA
             chooses the pseudorandom value k when signing a given message.
             This implementation was NOT optimized or hardened against
             side-channel leaks.
            
             An instance is created with a hash function name, which must be
             supported by the underlying Java virtual machine ("SHA-1" and
             "SHA-256" should work everywhere).  The data to sign is input
             through the {@code update()} methods.  The private key is set with
             {@link #setPrivateKey}.  The signature is obtained by calling
             {@link #sign}; alternatively, {@link #signHash} can be used to
             sign some data that has been externally hashed.  The private key
             MUST be set before generating the signature itself, but message
             data can be input before setting the key.
            
             Instances are NOT thread-safe.  However, once a signature has
             been generated, the same instance can be used again for another
             signature; {@link #setPrivateKey} need not be called again if the
             private key has not changed.  {@link #reset} can also be called to
             cancel previously input data.  Generating a signature with {@link
             #sign} (not {@link #signHash}) also implicitly causes a
             reset.
            
             ------------------------------------------------------------------
             Copyright (c) 2013 IETF Trust and the persons identified as
             authors of the code.  All rights reserved.
            
             Redistribution and use in source and binary forms, with or without
             modification, is permitted pursuant to, and subject to the license
             terms contained in, the Simplified BSD License set forth in Section
             4.c of the IETF Trust's Legal Provisions Relating to IETF Documents
             (http://trustee.ietf.org/license-info).
            
             Technical remarks and questions can be addressed to:
             pornin@bolet.org
             ------------------------------------------------------------------
        </member>
        <member name="M:NBitcoin.Crypto.DeterministicECDSA.#ctor(System.String)">
             Create an instance, using the specified hash function.
             The name is used to obtain from the JVM an implementation
             of the hash function and an implementation of HMAC.
            
             @param hashName   the hash function name
             @throws IllegalArgumentException  on unsupported name
        </member>
        <member name="M:NBitcoin.Crypto.DeterministicECDSA.setPrivateKey(NBitcoin.BouncyCastle.Math.BigInteger,NBitcoin.BouncyCastle.Math.BigInteger,NBitcoin.BouncyCastle.Math.BigInteger,NBitcoin.BouncyCastle.Math.BigInteger)">
             Set the private key.
            
             @param p   key parameter: field modulus
             @param q   key parameter: subgroup order
             @param g   key parameter: generator
             @param x   private key
        </member>
        <member name="M:NBitcoin.Crypto.DeterministicECDSA.setHmacKey(System.Byte[])">
             Set (or reset) the secret key used for HMAC.
            
             @param K   the new secret key
        </member>
        <member name="M:NBitcoin.Crypto.DeterministicECDSA.computek(System.Byte[])">
             Compute the pseudorandom k for signature generation,
             using the process specified for deterministic DSA.
            
             @param h1   the hashed message
             @return  the pseudorandom k to use
        </member>
        <member name="M:NBitcoin.Crypto.DeterministicECDSA.update(System.Byte)">
             Process one more byte of input data (message to sign).
            
             @param in   the extra input byte
        </member>
        <member name="M:NBitcoin.Crypto.DeterministicECDSA.update(System.Byte[])">
             Process some extra bytes of input data (message to sign).
            
             @param in   the extra input bytes
        </member>
        <member name="M:NBitcoin.Crypto.DeterministicECDSA.update(System.Byte[],System.Int32,System.Int32)">
             Process some extra bytes of input data (message to sign).
            
             @param in    the extra input buffer
             @param off   the extra input offset
             @param len   the extra input length (in bytes)
        </member>
        <member name="M:NBitcoin.Crypto.DeterministicECDSA.sign">
             Produce the signature.  {@link #setPrivateKey} MUST have
             been called.  The signature is computed over the data
             that was input through the {@code update*()} methods.
             This engine is then reset (made ready for a new
             signature generation).
            
             @return  the signature
        </member>
        <member name="M:NBitcoin.Crypto.DeterministicECDSA.signHash(System.Byte[])">
             Produce the signature.  {@link #setPrivateKey} MUST
             have been called.  The signature is computed over the
             provided hash value (data is assumed to have been hashed
             externally).  The data that was input through the
             {@code update*()} methods is ignored, but kept.
            
             If the hash output is longer than the subgroup order
             (the length of q, in bits, denoted 'qlen'), then the
             provided value {@code h1} can be truncated, provided that
             at least qlen leading bits are preserved.  In other words,
             bit values in {@code h1} beyond the first qlen bits are
             ignored.
            
             @param h1   the hash value
             @return  the signature
        </member>
        <member name="M:NBitcoin.Crypto.DeterministicECDSA.reset">
            Reset this engine.  Data input through the {@code
            update*()} methods is discarded.  The current private key,
            if one was set, is kept unchanged.
        </member>
        <member name="M:NBitcoin.Crypto.ECDSASignature.ToDER">
            What we get back from the signer are the two components of a signature, r and s. To get a flat byte stream
            of the type used by Bitcoin we have to encode them using DER encoding, which is just a way to pack the two
            components into a structure.
        </member>
        <member name="M:NBitcoin.Key.GetWif(NBitcoin.Network)">
            <summary>
            Same than GetBitcoinSecret
            </summary>
            <param name="network"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.MnemonicReference.CreateAsync(NBitcoin.ChainBase,NBitcoin.IBlockRepository,System.Int32,System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="chain"></param>
            <param name="blockRepository"></param>
            <param name="blockHeight"></param>
            <param name="txIndex"></param>
            <param name="txOutIndex"></param>
            <exception cref="T:NBitcoin.InvalidBrainAddressException"></exception>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Money.TryParse(System.String,NBitcoin.Money@)">
            <summary>
            Parse a bitcoin amount (Culture Invariant)
            </summary>
            <param name="bitcoin"></param>
            <param name="nRet"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Money.Parse(System.String)">
            <summary>
            Parse a bitcoin amount (Culture Invariant)
            </summary>
            <param name="bitcoin"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Money.Abs">
            <summary>
            Get absolute value of the instance
            </summary>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Money.Split(System.Int32)">
            <summary>
            Split the Money in parts without loss
            </summary>
            <param name="parts">The number of parts (must be more than 0)</param>
            <returns>The splitted money</returns>
        </member>
        <member name="M:NBitcoin.Money.ToUnit(NBitcoin.MoneyUnit)">
            <summary>
            Convert Money to decimal (same as ToDecimal)
            </summary>
            <param name="unit"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Money.ToDecimal(NBitcoin.MoneyUnit)">
            <summary>
            Convert Money to decimal (same as ToUnit)
            </summary>
            <param name="unit"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Money.ToString">
            <summary>
            Returns a culture invariant string representation of Bitcoin amount
            </summary>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Money.ToString(System.Boolean,System.Boolean)">
            <summary>
            Returns a culture invariant string representation of Bitcoin amount
            </summary>
            <param name="fplus">True if show + for a positive amount</param>
            <param name="trimExcessZero">True if trim excess zeroes</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Money.Almost(NBitcoin.Money,NBitcoin.Money)">
            <summary>
            Tell if amount is almost equal to this instance
            </summary>
            <param name="amount"></param>
            <param name="dust">more or less dust (default : 600 satoshi)</param>
            <returns>true if equals, else false</returns>
        </member>
        <member name="M:NBitcoin.Money.Almost(NBitcoin.Money,System.Decimal)">
            <summary>
            Tell if amount is almost equal to this instance
            </summary>
            <param name="amount"></param>
            <param name="margin">error margin (between 0 and 1)</param>
            <returns>true if equals, else false</returns>
        </member>
        <member name="M:NBitcoin.Network.CreateBitcoinAddress(System.String)">
            <summary>
            Create a bitcoin address from base58 data, return a BitcoinAddress or BitcoinScriptAddress
            </summary>
            <param name="base58">base58 address</param>
            <exception cref="T:System.FormatException">Invalid base58 address</exception>
            <returns>BitcoinScriptAddress, BitcoinAddress</returns>
        </member>
        <member name="M:NBitcoin.Network.CreateFromBase58Data(System.String,NBitcoin.Network)">
            <summary>
            Find automatically the data type and the network to which belong the base58 data
            </summary>
            <param name="base58">base58 data</param>
            <exception cref="T:System.FormatException">Invalid base58 data</exception>
        </member>
        <member name="T:NBitcoin.OpenAsset.AssetId">
            <summary>
            A unique Id for an asset
            </summary>
        </member>
        <member name="M:NBitcoin.OpenAsset.AssetMoney.Abs">
            <summary>
            Get absolute value of the instance
            </summary>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.OpenAsset.AssetMoney.Split(System.Int32)">
            <summary>
            Split the Money in parts without loss
            </summary>
            <param name="parts">The number of parts (must be more than 0)</param>
            <returns>The splitted money</returns>
        </member>
        <member name="P:NBitcoin.OpenAsset.AssetMoney.Id">
            <summary>
            AssetId of the current amount
            </summary>
        </member>
        <member name="T:NBitcoin.OpenAsset.BitcoinAssetId">
            <summary>
            Base58 representation of an asset id
            </summary>
        </member>
        <member name="M:NBitcoin.PartialMerkleTree.Trim(NBitcoin.uint256[])">
            <summary>
            Remove superflous branches
            </summary>
            <param name="transaction"></param>
            <returns></returns>
        </member>
        <member name="T:NBitcoin.Payment.BitcoinUrlBuilder">
            <summary>
            https://github.com/bitcoin/bips/blob/master/bip-0021.mediawiki
            </summary>
        </member>
        <member name="P:NBitcoin.Payment.BitcoinUrlBuilder.PaymentRequestUrl">
            <summary>
            https://github.com/bitcoin/bips/blob/master/bip-0072.mediawiki
            </summary>
        </member>
        <member name="M:System.Web.NBitcoin.HttpUtility.HtmlDecode(System.String)">
            <summary>
            Decodes an HTML-encoded string and returns the decoded string.
            </summary>
            <param name="s">The HTML string to decode. </param>
            <returns>The decoded text.</returns>
        </member>
        <member name="M:System.Web.NBitcoin.HttpUtility.HtmlDecode(System.String,System.IO.TextWriter)">
            <summary>
            Decodes an HTML-encoded string and sends the resulting output to a TextWriter output stream.
            </summary>
            <param name="s">The HTML string to decode</param>
            <param name="output">The TextWriter output stream containing the decoded string. </param>
        </member>
        <member name="M:System.Web.NBitcoin.HttpUtility.HtmlEncode(System.String,System.IO.TextWriter)">
            <summary>
            HTML-encodes a string and sends the resulting output to a TextWriter output stream.
            </summary>
            <param name="s">The string to encode. </param>
            <param name="output">The TextWriter output stream containing the encoded string. </param>
        </member>
        <member name="F:NBitcoin.Protocol.Message._SkipMagic">
            <summary>
            When parsing, maybe Magic is already parsed
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.AlertPayload.Now">
            <summary>
            Used for knowing if an alert is valid in past of future
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.BlockPayload">
            <summary>
            A block received after being asked with a getdata message
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.FilterLoadPayload">
            <summary>
            Load a bloomfilter in the peer, used by SPV clients
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.GetAddrPayload">
            <summary>
            Ask for known peer addresses in the network
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.GetBlocksPayload">
            <summary>
            Ask for the block hashes (inv) that happened since BlockLocators
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.GetDataPayload">
            <summary>
            Ask for transaction, block or merkle block
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.GetHeadersPayload">
            <summary>
            Ask block headers that happened since BlockLocators
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.HeadersPayload">
            <summary>
            Block headers received after a getheaders messages
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.InvPayload">
            <summary>
            Announce the hash of a transaction or block
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.MempoolPayload">
            <summary>
            Ask for the mempool, followed by inv messages
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.MerkleBlockPayload">
            <summary>
            A merkle block received after being asked with a getdata message
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.NotFoundPayload">
            <summary>
            A getdata message for an asked hash is not found by the remote peer
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.TxPayload">
            <summary>
            Represents a transaction being sent on the network, is sent after being requested by a getdata (of Transaction or MerkleBlock) message.
            </summary>
        </member>
        <member name="M:NBitcoin.PubKey.#ctor(System.String)">
            <summary>
            Create a new Public key from string
            </summary>
        </member>
        <member name="M:NBitcoin.PubKey.#ctor(System.Byte[])">
            <summary>
            Create a new Public key from byte array
            </summary>
        </member>
        <member name="M:NBitcoin.PubKey.#ctor(System.Byte[],System.Boolean)">
            <summary>
            Create a new Public key from byte array
            </summary>
            <param name="bytes">byte array</param>
            <param name="unsafe">If false, make internal copy of bytes and does perform only a costly check for PubKey format. If true, the bytes array is used as is and only PubKey.QuickCheck is used for validating the format. </param>	 
        </member>
        <member name="M:NBitcoin.PubKey.Check(System.Byte[],System.Boolean)">
            <summary>
            Check on public key format.
            </summary>
            <param name="data">bytes array</param>
            <param name="deep">If false, will only check the first byte and length of the array. If true, will also check that the ECC coordinates are correct.</param>
            <returns>true if byte array is valid</returns>
        </member>
        <member name="T:NBitcoin.RPC.RestClient">
            <summary>
            Client class for the <see cref="!:https://github.com/bitcoin/bitcoin/blob/master/doc/REST-interface.md">
            Unauthenticated REST Interface</see> 
            </summary>
        </member>
        <member name="M:NBitcoin.RPC.RestClient.#ctor(System.Uri)">
            <summary>
            Initializes a new instance of the <see cref="T:NBitcoin.RPC.RestClient"/> class.
            </summary>
            <param name="serviceEndpoint">The rest API endpoint.</param>
        </member>
        <member name="M:NBitcoin.RPC.RestClient.#ctor(System.Uri,NBitcoin.RPC.RestResponseFormat)">
            <summary>
            Initializes a new instance of the <see cref="T:NBitcoin.RPC.RestClient"/> class.
            </summary>
            <param name="address">The rest API endpoint</param>
            <param name="format">The format (bin | hex | json).</param>
            <exception cref="T:System.ArgumentNullException">Null rest API endpoint</exception>
            <exception cref="T:System.ArgumentException">Invalid value for RestResponseFormat</exception>
        </member>
        <member name="M:NBitcoin.RPC.RestClient.GetBlockAsync(NBitcoin.uint256)">
            <summary>
            Gets the block.
            </summary>
            <param name="blockId">The block identifier.</param>
            <returns>Given a block hash (id) returns the requested block object.</returns>
            <exception cref="T:System.ArgumentNullException">blockId cannot be null.</exception>
        </member>
        <member name="M:NBitcoin.RPC.RestClient.GetBlock(NBitcoin.uint256)">
            <summary>
            Gets the block.
            </summary>
            <param name="blockId">The block identifier.</param>
            <returns>Given a block hash (id) returns the requested block object.</returns>
            <exception cref="T:System.ArgumentNullException">blockId cannot be null.</exception>
        </member>
        <member name="M:NBitcoin.RPC.RestClient.GetTransactionAsync(NBitcoin.uint256)">
            <summary>
            Gets a transaction.
            </summary>
            <param name="txId">The transaction identifier.</param>
            <returns>Given a transaction hash (id) returns the requested transaction object.</returns>
            <exception cref="T:System.ArgumentNullException">txId cannot be null</exception>
        </member>
        <member name="M:NBitcoin.RPC.RestClient.GetTransaction(NBitcoin.uint256)">
            <summary>
            Gets a transaction.
            </summary>
            <param name="txId">The transaction identifier.</param>
            <returns>Given a transaction hash (id) returns the requested transaction object.</returns>
            <exception cref="T:System.ArgumentNullException">txId cannot be null</exception>
        </member>
        <member name="M:NBitcoin.RPC.RestClient.GetBlockHeadersAsync(NBitcoin.uint256,System.Int32)">
            <summary>
            Gets blocks headers.
            </summary>
            <param name="blockId">The initial block identifier.</param>
            <param name="count">how many headers to get.</param>
            <returns>Given a block hash (blockId) returns as much block headers as specified.</returns>
            <exception cref="T:System.ArgumentNullException">blockId cannot be null</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">count must be greater or equal to one.</exception>
        </member>
        <member name="M:NBitcoin.RPC.RestClient.GetBlockHeaders(NBitcoin.uint256,System.Int32)">
            <summary>
            Gets blocks headers.
            </summary>
            <param name="blockId">The initial block identifier.</param>
            <param name="count">how many headers to get.</param>
            <returns>Given a block hash (blockId) returns as much block headers as specified.</returns>
            <exception cref="T:System.ArgumentNullException">blockId cannot be null</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">count must be greater or equal to one.</exception>
        </member>
        <member name="M:NBitcoin.RPC.RestClient.GetChainInfoAsync">
            <summary>
            Gets the chain information.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.RPC.RestClient.GetUnspentOutputsAsync(System.Collections.Generic.IEnumerable{NBitcoin.OutPoint},System.Boolean)">
            <summary>
            Gets unspect outputs.
            </summary>
            <param name="outPoints">The out points identifiers (TxIn-N).</param>
            <param name="checkMempool">if set to <c>true</c> [check mempool].</param>
            <returns>The unspent transaction outputs (UTXO) for the given outPoints.</returns>
            <exception cref="T:System.ArgumentNullException">outPoints cannot be null.</exception>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.SendCommand(System.String,System.Object[])">
            <summary>
            Send a command
            </summary>
            <param name="commandName">https://en.bitcoin.it/wiki/Original_Bitcoin_client/API_calls_list</param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.GetBlockAsync(NBitcoin.uint256)">
            <summary>
            Get the a whole block
            </summary>
            <param name="blockId"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.GetBlock(NBitcoin.uint256)">
            <summary>
            Get the a whole block
            </summary>
            <param name="blockId"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.GetRawTransaction(NBitcoin.uint256,System.Boolean)">
            <summary>
            getrawtransaction only returns on txn which are not entirely spent unless you run bitcoinq with txindex=1.
            </summary>
            <param name="txid"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.GetTransactions(NBitcoin.uint256)">
            <summary>
            GetTransactions only returns on txn which are not entirely spent unless you run bitcoinq with txindex=1.
            </summary>
            <param name="blockHash"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.EstimateFee(System.Int32)">
            <summary>
            Get the estimated fee per kb for being confirmed in nblock
            </summary>
            <param name="nblock"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.EstimateFeeAsync(System.Int32)">
            <summary>
            Get the estimated fee per kb for being confirmed in nblock
            </summary>
            <param name="nblock"></param>
            <returns></returns>
        </member>
        <member name="T:NBitcoin.ScriptVerify">
            Script verification flags 
        </member>
        <member name="F:NBitcoin.ScriptVerify.P2SH">
            <summary>
            Evaluate P2SH subscripts (softfork safe, BIP16).
            </summary>
        </member>
        <member name="F:NBitcoin.ScriptVerify.StrictEnc">
            <summary>
            Passing a non-strict-DER signature or one with undefined hashtype to a checksig operation causes script failure.
            Passing a pubkey that is not (0x04 + 64 bytes) or (0x02 or 0x03 + 32 bytes) to checksig causes that pubkey to be
            +
            skipped (not softfork safe: this flag can widen the validity of OP_CHECKSIG OP_NOT).
            </summary>
        </member>
        <member name="F:NBitcoin.ScriptVerify.DerSig">
            <summary>
            Passing a non-strict-DER signature to a checksig operation causes script failure (softfork safe, BIP62 rule 1)
            </summary>
        </member>
        <member name="F:NBitcoin.ScriptVerify.LowS">
            <summary>
            Passing a non-strict-DER signature or one with S > order/2 to a checksig operation causes script failure
            (softfork safe, BIP62 rule 5).
            </summary>
        </member>
        <member name="F:NBitcoin.ScriptVerify.NullDummy">
            <summary>
            verify dummy stack item consumed by CHECKMULTISIG is of zero-length (softfork safe, BIP62 rule 7).
            </summary>
        </member>
        <member name="F:NBitcoin.ScriptVerify.SigPushOnly">
            <summary>
            Using a non-push operator in the scriptSig causes script failure (softfork safe, BIP62 rule 2).
            </summary>
        </member>
        <member name="F:NBitcoin.ScriptVerify.Mandatory">
            Mandatory script verification flags that all new blocks must comply with for
            them to be valid. (but old blocks may not comply with) Currently just P2SH,
            but in the future other flags may be added, such as a soft-fork to enforce
            strict DER encoding.
            
            Failing one of these tests may trigger a DoS ban - see CheckInputs() for
            details.
        </member>
        <member name="F:NBitcoin.ScriptVerify.Standard">
            Standard script verification flags that standard transactions will comply
            with. However scripts violating these flags may still be present in valid
            blocks and we must accept those blocks.
        </member>
        <member name="T:NBitcoin.SigHash">
            Signature hash types/flags 
        </member>
        <member name="F:NBitcoin.SigHash.All">
            <summary>
            All outputs are signed
            </summary>
        </member>
        <member name="F:NBitcoin.SigHash.None">
            <summary>
            No outputs as signed
            </summary>
        </member>
        <member name="F:NBitcoin.SigHash.Single">
            <summary>
            Only the output with the same index as this input is signed
            </summary>
        </member>
        <member name="F:NBitcoin.SigHash.AnyoneCanPay">
            <summary>
            If set, no inputs, except this, are part of the signature
            </summary>
        </member>
        <member name="T:NBitcoin.OpcodeType">
            Script opcodes 
        </member>
        <member name="M:NBitcoin.Script.GetSignerAddress(NBitcoin.Network)">
            <summary>
            Extract P2SH or P2PH address from scriptSig
            </summary>
            <param name="network"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Script.GetSigner">
            <summary>
            Extract P2SH or P2PH id from scriptSig
            </summary>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Script.GetDestinationAddress(NBitcoin.Network)">
            <summary>
            Extract P2SH or P2PH address from scriptPubKey
            </summary>
            <param name="network"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Script.GetDestination">
            <summary>
            Extract P2SH or P2PH id from scriptPubKey
            </summary>
            <param name="network"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Script.GetDestinationPublicKeys">
            <summary>
            Extract public keys if this script is a multi sig or pay to pub key scriptPubKey
            </summary>
            <param name="network"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Script.ToRawScript">
            <summary>
            Get script byte array
            </summary>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Script.ToBytes">
            <summary>
            Get script byte array
            </summary>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Script.ToRawScript(System.Boolean)">
            <summary>
            Get script byte array
            </summary>
            <param name="unsafe">if false, returns a copy of the internal byte array</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Script.ToBytes(System.Boolean)">
            <summary>
            Get script byte array
            </summary>
            <param name="unsafe">if false, returns a copy of the internal byte array</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Script.CreateFromDestination(NBitcoin.TxDestination)">
            <summary>
            Create scriptPubKey from destination id
            </summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Script.CreateFromDestinationAddress(NBitcoin.BitcoinAddress)">
            <summary>
            Create scriptPubKey from destination address
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.ScriptEvaluationContext.CScriptNum.#ctor(System.Int64)">
            Numeric opcodes (OP_1ADD, etc) are restricted to operating on 4-byte integers.
            The semantics are subtle, though: operands must be in the range [-2^31 +1...2^31 -1],
            but results may overflow (and are valid as long as they are not used in a subsequent
            numeric operation). CScriptNum enforces those semantics by storing results as
            an int64 and allowing out-of-range values to be returned as a vector of bytes but
            throwing an exception if arithmetic is done or the result is interpreted as an integer.
        </member>
        <member name="T:NBitcoin.ContextStack`1">
            <summary>
            ContextStack is used internally by the bitcoin script evaluator. This class contains
            operations not typically available in a "pure" Stack class, as example:
            Insert, Swap, Erase and Top (Peek w/index)
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:NBitcoin.ContextStack`1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NBitcoin.ContextStack`1"/> class.
            </summary>
        </member>
        <member name="M:NBitcoin.ContextStack`1.#ctor(NBitcoin.ContextStack{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:NBitcoin.ContextStack`1"/> 
            base on another stack. This is for copy/clone. 
            </summary>
            <param name="stack">The stack.</param>
        </member>
        <member name="M:NBitcoin.ContextStack`1.Push(`0)">
            <summary>
            Pushes the specified item on the stack.
            </summary>
            <param name="item">The item to by pushed.</param>
        </member>
        <member name="M:NBitcoin.ContextStack`1.Pop">
            <summary>
            Pops this element in top of the stack.
            </summary>
            <returns>The element in top of the stack</returns>
        </member>
        <member name="M:NBitcoin.ContextStack`1.Clear(System.Int32)">
            <summary>
            Pops as many items as specified.
            </summary>
            <param name="n">The number of items to be poped</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Cannot remove more elements</exception>
        </member>
        <member name="M:NBitcoin.ContextStack`1.Top(System.Int32)">
            <summary>
            Returns the i-th element from the top of the stack.
            </summary>
            <param name="i">The i-th index.</param>
            <returns>the i-th element from the top of the stack</returns>
            <exception cref="T:System.IndexOutOfRangeException">topIndex</exception>
        </member>
        <member name="M:NBitcoin.ContextStack`1.Swap(System.Int32,System.Int32)">
            <summary>
            Swaps the specified i and j elements in the stack.
            </summary>
            <param name="i">The i-th index.</param>
            <param name="j">The j-th index.</param>
            <exception cref="T:System.IndexOutOfRangeException">
            i or  j
            </exception>
        </member>
        <member name="M:NBitcoin.ContextStack`1.Insert(System.Int32,`0)">
            <summary>
            Inserts an item in the specified position.
            </summary>
            <param name="position">The position.</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:NBitcoin.ContextStack`1.Remove(System.Int32)">
            <summary>
            Removes the i-th item.
            </summary>
            <param name="from">The item position</param>
        </member>
        <member name="M:NBitcoin.ContextStack`1.Remove(System.Int32,System.Int32)">
            <summary>
            Removes items from the i-th position to the j-th position.
            </summary>
            <param name="from">The item position</param>
            <param name="to">The item position</param>
        </member>
        <member name="M:NBitcoin.ContextStack`1.AsInternalArray">
            <summary>
            Returns a copy of the internal array.
            </summary>
            <returns>A copy of the internal array</returns>
        </member>
        <member name="P:NBitcoin.ContextStack`1.Count">
            <summary>
            Gets the number of items in the stack.
            </summary>
        </member>
        <member name="T:NBitcoin.ContextStack`1.Enumerator">
            <summary>
            Implements a reverse enumerator for the ContextStack
            </summary>
        </member>
        <member name="M:NBitcoin.Stealth.BitcoinStealthAddress.GetPayments(NBitcoin.Transaction,NBitcoin.Key)">
            <summary>
            Scan the Transaction for StealthCoin given address and scan key
            </summary>
            <param name="tx">The transaction to scan</param>
            <param name="address">The stealth address</param>
            <param name="scan">The scan private key</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Stealth.BitcoinStealthAddress.GetPayments(NBitcoin.Transaction,NBitcoin.ISecret)">
            <summary>
            Scan the Transaction for StealthCoin given address and scan key
            </summary>
            <param name="tx">The transaction to scan</param>
            <param name="address">The stealth address</param>
            <param name="scan">The scan private key</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Stealth.BitcoinStealthAddress.CreatePayment(NBitcoin.Key)">
            <summary>
            Prepare a stealth payment 
            </summary>
            <param name="ephemKey">Ephem Key</param>
            <returns>Stealth Payment</returns>
        </member>
        <member name="M:NBitcoin.Stealth.BitcoinStealthAddress.SendTo(NBitcoin.Transaction,NBitcoin.Money,NBitcoin.Key)">
            <summary>
            Add a stealth payment to the transaction
            </summary>
            <param name="transaction">Destination transaction</param>
            <param name="value">Money to send</param>
            <param name="ephemKey">Ephem Key</param>
        </member>
        <member name="T:NBitcoin.Target">
            <summary>
            Represent the challenge that miners must solve for finding a new block
            </summary>
        </member>
        <member name="P:NBitcoin.IndexedTxIn.Index">
            <summary>
            The index of this TxIn in its transaction
            </summary>
        </member>
        <member name="M:NBitcoin.Transaction.Sign(NBitcoin.ISecret,System.Boolean)">
            <summary>
            Sign the transaction with a private key
            <para>ScriptSigs should be filled with previous ScriptPubKeys</para>
            <para>For more complex scenario, use TransactionBuilder</para>
            </summary>
            <param name="secret"></param>
        </member>
        <member name="M:NBitcoin.Transaction.Sign(NBitcoin.Key,System.Boolean)">
            <summary>
            Sign the transaction with a private key
            <para>ScriptSigs should be filled with either previous scriptPubKeys or redeem script (for P2SH)</para>
            <para>For more complex scenario, use TransactionBuilder</para>
            </summary>
            <param name="secret"></param>
        </member>
        <member name="T:NBitcoin.DefaultCoinSelector">
            <summary>
            Algorithm implemented by bitcoin core https://github.com/bitcoin/bitcoin/blob/master/src/wallet.cpp#L1276
            Minimize the change
            </summary>
        </member>
        <member name="T:NBitcoin.NotEnoughFundsException">
            <summary>
            Exception thrown when not enough funds are present for verifying or building a transaction
            </summary>
        </member>
        <member name="P:NBitcoin.NotEnoughFundsException.Group">
            <summary>
            The group name who is missing the funds
            </summary>
        </member>
        <member name="P:NBitcoin.NotEnoughFundsException.Missing">
            <summary>
            Amount of Money missing
            </summary>
        </member>
        <member name="T:NBitcoin.TransactionBuilder">
            <summary>
            A class for building and signing all sort of transactions easily (http://www.codeproject.com/Articles/835098/NBitcoin-Build-Them-All)
            </summary>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.SetGroupName(System.String)">
            <summary>
            Set the name of this group (group are separated by call to Then())
            </summary>
            <param name="groupName">Name of the group</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.Send(NBitcoin.IDestination,NBitcoin.Money)">
            <summary>
            Send bitcoins to a destination
            </summary>
            <param name="destination">The destination</param>
            <param name="amount">The amount</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.Send(NBitcoin.Script,NBitcoin.Money)">
            <summary>
            Send bitcoins to a destination
            </summary>
            <param name="scriptPubKey">The destination</param>
            <param name="amount">The amount</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.Send(NBitcoin.IDestination,NBitcoin.IMoney)">
            <summary>
            Send a money amount to the destination
            </summary>
            <param name="destination">The destination</param>
            <param name="amount">The amount (supported : Money, AssetMoney, MoneyBag)</param>
            <returns></returns>
            <exception cref="T:System.NotSupportedException">The coin type is not supported</exception>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.Send(NBitcoin.Script,NBitcoin.IMoney)">
            <summary>
            Send a money amount to the destination
            </summary>
            <param name="destination">The destination</param>
            <param name="amount">The amount (supported : Money, AssetMoney, MoneyBag)</param>
            <returns></returns>
            <exception cref="T:System.NotSupportedException">The coin type is not supported</exception>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.SendAsset(NBitcoin.IDestination,NBitcoin.OpenAsset.AssetMoney)">
            <summary>
            Send assets (Open Asset) to a destination
            </summary>
            <param name="destination">The destination</param>
            <param name="asset">The asset and amount</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.SendAsset(NBitcoin.IDestination,NBitcoin.OpenAsset.AssetId,System.UInt64)">
            <summary>
            Send assets (Open Asset) to a destination
            </summary>
            <param name="destination">The destination</param>
            <param name="asset">The asset and amount</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.SendEstimatedFeesSplit(NBitcoin.Money)">
            <summary>
            Split the estimated fees accross the several groups (separated by Then())
            </summary>
            <param name="fees"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.SendFeesSplit(NBitcoin.Money)">
            <summary>
            Split the fees accross the several groups (separated by Then())
            </summary>
            <param name="fees"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.BuildTransaction(System.Boolean)">
            <summary>
            Build the transaction
            </summary>
            <param name="sign">True if signs all inputs with the available keys</param>
            <returns>The transaction</returns>
            <exception cref="T:NBitcoin.NotEnoughFundsException">Not enough funds are available</exception>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.BuildTransaction(System.Boolean,NBitcoin.SigHash)">
            <summary>
            Build the transaction
            </summary>
            <param name="sign">True if signs all inputs with the available keys</param>
            <param name="sigHash">The type of signature</param>
            <returns>The transaction</returns>
            <exception cref="T:NBitcoin.NotEnoughFundsException">Not enough funds are available</exception>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.Verify(NBitcoin.Transaction,NBitcoin.Money)">
            <summary>
            Verify that a transaction is fully signed and have enough fees
            </summary>
            <param name="tx">The transaction to verify</param>
            <param name="expectedFees">The expected fees (if null, do not verify)</param>
            <returns>True if the verification pass</returns>
            <exception cref="T:NBitcoin.NotEnoughFundsException">Not enough funds are available</exception>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.EstimateFees(NBitcoin.Transaction,NBitcoin.Money)">
            <summary>
            Estimate fees of an unsigned transaction
            </summary>
            <param name="tx"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.EstimateFees(NBitcoin.Transaction)">
            <summary>
            Estimate fees of an unsigned transaction
            </summary>
            <param name="tx"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.CoverOnly(NBitcoin.Money)">
            <summary>
            Specify the amount of money to cover txouts, if not specified all txout will be covered
            </summary>
            <param name="amount"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.ContinueToBuild(NBitcoin.Transaction)">
            <summary>
            Allows to keep building on the top of a partially built transaction
            </summary>
            <param name="transaction">Transaction to complete</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.CoverTheRest">
            <summary>
            Will cover the remaining amount of TxOut of a partially built transaction (to call after ContinueToBuild)
            </summary>
            <returns></returns>
        </member>
        <member name="P:NBitcoin.TransactionBuilder.DustPrevention">
            <summary>
            Will transform transfers below 600 satoshi to fees, so the transaction get correctly relayed by the network.
            </summary>
        </member>
        <member name="P:NBitcoin.TransactionBuilder.CoinFinder">
            <summary>
            A callback used by the TransactionBuilder when it does not find the coin for an input
            </summary>
        </member>
        <member name="P:NBitcoin.TransactionBuilder.KeyFinder">
            <summary>
            A callback used by the TransactionBuilder when it does not find the key for a scriptPubKey
            </summary>
        </member>
        <member name="P:NBitcoin.TransactionBuilder.ColoredDust">
            <summary>
            The amount of satoshi to use for outputs bearing an Asset
            </summary>
        </member>
        <member name="M:NBitcoin.Extensions.ToUnixTimestamp(System.DateTime)">
            <summary>
            Converts a given DateTime into a Unix timestamp
            </summary>
            <param name="value">Any DateTime</param>
            <returns>The given DateTime in Unix timestamp format</returns>
        </member>
        <member name="M:NBitcoin.Extensions.UnixTimestamp(System.DateTime)">
            <summary>
            Gets a Unix timestamp representing the current moment
            </summary>
            <param name="ignored">Parameter ignored</param>
            <returns>Now expressed as a Unix timestamp</returns>
        </member>
        <member name="F:NBitcoin.ValidationState.MAX_BLOCK_SIGOPS">
            The maximum number of sigops we're willing to relay/mine in a single tx 
        </member>
        <member name="T:System.Numerics.BigIntegerBuilder">
            <summary>
            BigIntegerBuilder holds a multiprecision unsigned integer value. It is mutable and
            supports common arithmetic operations. Be careful NOT to simply assign one
            BigIntegerBuilder to another, unless you really know what you are doing. The proper
            way to replicate a BigIntegerBuilder is via the constructor "BigIntegerBuilder(ref BigIntegerBuilder reg)",
            or with reg1.Load(ref reg2). Using the ctor marks the buffer as shared so changing the
            value of one register will not affect the other. Using Load copies the contents from
            one to the other. Either way, the internal buffer isn't aliased incorrectly.
            </summary>
        </member>
    </members>
</doc>
